<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>clash机场中转配置生成器</title>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <style>
        :root {
            --primary-color: #007bff; --secondary-color: #6c757d; --success-color: #28a745;
            --danger-color: #dc3545; --light-color: #f8f9fa; --dark-color: #343a40;
            --border-color: #dee2e6; --warning-color: #ffc107;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6; background-color: var(--light-color); color: var(--dark-color);
            margin: 0; padding: 20px; display: flex; justify-content: center;
        }
        .container { max-width: 900px; width: 100%; background-color: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 6px 20px rgba(0,0,0,0.08); }
        h1 { text-align: center; color: var(--dark-color); border-bottom: 2px solid var(--primary-color); padding-bottom: 15px; margin-bottom: 25px; }
        .step { margin-bottom: 25px; padding: 20px; border: 1px solid var(--border-color); border-radius: 6px; background-color: #fff; }
        label, .label-like { display: block; font-weight: bold; font-size: 1.1em; margin-bottom: 10px; color: var(--primary-color); }
        textarea { width: 100%; min-height: 150px; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; resize: vertical; box-sizing: border-box; font-family: 'Courier New', Courier, monospace; font-size: 14px; }
        button { padding: 12px 25px; background-color: var(--primary-color); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold; transition: background-color 0.3s, transform 0.2s; display: block; margin: 15px auto 0; }
        button:hover:not(:disabled) { background-color: #0056b3; transform: translateY(-2px); }
        button:disabled { background-color: var(--secondary-color); cursor: not-allowed; }
        #selectors-container, .multi-exit-options { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px; }
        select, input[type="number"] { width: 100%; padding: 10px; border-radius: 4px; border: 1px solid var(--border-color); font-size: 16px; background-color: #fff; box-sizing: border-box; }
        .output-container { position: relative; }
        #copyButton { position: absolute; top: 45px; right: 15px; background-color: var(--success-color); padding: 8px 15px; font-size: 14px; margin: 0; }
        #copyButton:hover { background-color: #218838; }
        #downloadButton { position: absolute; top: 45px; right: 85px; background-color: var(--primary-color); padding: 8px 15px; font-size: 14px; margin: 0; }
        #downloadButton:hover { background-color: #0056b3; }
        #status { text-align: center; margin-top: 15px; font-weight: bold; min-height: 24px; transition: color 0.3s; }
        .status-success { color: var(--success-color); }
        .status-error { color: var(--danger-color); }
        .status-info { color: var(--secondary-color); }
        .note { font-size: 0.9em; color: var(--secondary-color); margin-top: 10px; padding: 10px; background-color: #fdfdfe; border-left: 3px solid var(--warning-color); }
        .feature-toggle { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; }
        .feature-toggle input { width: auto; height: 18px; width: 18px; }
        .feature-toggle label { margin-bottom: 0; font-size: 1em; color: var(--dark-color); }
        #multiExitContainer { border-top: 1px dashed var(--border-color); margin-top: 15px; padding-top: 15px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>clash机场中转配置生成器</h1>

        <div class="step">
            <label for="yamlInput">第一步：粘贴您的基础配置</label>
            <textarea id="yamlInput" placeholder="可以是一个完整的配置，也可以只包含 rules 和 proxy-groups。如果为空，将使用一个基础模板。"></textarea>
            <button id="parseButton">解析并载入</button>
        </div>

        <div id="interaction-zone" style="display: none;">
            <div class="step">
                <label for="uriInput">第二步：手动添加节点 (可选)</label>
                <textarea id="uriInput" placeholder="在此处粘贴一个或多个节点链接 (ss://, vmess://, vless://, trojan://, tuic://, hysteria2://...)，每行一个。"></textarea>
                <button id="addNodesButton">添加节点到列表</button>
            </div>

            <div class="step">
                <label>第三步：选择生成模式</label>
                
                <div id="chainProxyContainer">
                    <span class="label-like">模式A：配置链式代理 (dialer-proxy)</span>
                    <div id="selectors-container">
                        <div>
                            <span>选择“跳板” (B)</span>
                            <select id="middlemanProxy"></select>
                        </div>
                        <div>
                            <span>选择“出口” (A)</span>
                            <select id="exitProxy"></select>
                        </div>
                    </div>
                    <div class="note">将出口(A)的流量通过跳板(B)发出。如果不需要，保持“不选择”。</div>
                </div>

                <div id="multiExitContainer">
                    <div class="feature-toggle">
                       <input type="checkbox" id="generateListenersCheckbox">
                       <label for="generateListenersCheckbox" class="label-like">模式B：生成多出口本地监听 (Listeners)</label>
                    </div>
                    <div id="multiExitOptions" style="display:none;">
                         <div>
                            <label for="startPortInput" style="font-size:1em; color:#333;">起始端口</label>
                            <input type="number" id="startPortInput" value="8000">
                        </div>
                        <div>
                            <label for="listenerTypeSelect" style="font-size:1em; color:#333;">监听类型</label>
                            <select id="listenerTypeSelect">
                                <option value="mixed">mixed</option>
                                <option value="http">http</option>
                                <option value="socks">socks</option>
                            </select>
                        </div>
                    </div>
                    <div class="note">为每一个代理节点创建一个独立的本地S5/HTTP端口。勾选此项将禁用上方的链式代理模式。</div>
                </div>
            </div>

            <div class="step">
                <button id="generateButton">生成最终配置</button>
            </div>

            <div class="step output-container">
                <label for="yamlOutput">第四步：复制或下载最终配置</label>
                <textarea id="yamlOutput" readonly placeholder="点击上方按钮生成新配置..."></textarea>
                <button id="downloadButton" style="display: none;">下载</button>
                <button id="copyButton" style="display: none;">复制</button>
            </div>
        </div>
        <div id="status"></div>
    </div>

    <script>
        let parsedConfig = null;
        const BASE_TEMPLATE = `port: 7890\nsocks-port: 7891\nallow-lan: false\nmode: rule\nlog-level: info\nexternal-controller: 127.0.0.1:9090\nproxies: []\nproxy-groups:  \n  - name: PROXY\n    type: select\n    proxies:\n      - DIRECT\nrules:\n  - MATCH,PROXY`;
        
        const DNS_TEMPLATE = {
            enable: true,
            'enhanced-mode': 'fake-ip',
            'fake-ip-range': '198.18.0.1/16',
            'default-nameserver': ['114.114.114.114'],
            nameserver: ['https://doh.pub/dns-query']
        };

        const ui = {
            parseButton: document.getElementById('parseButton'),
            addNodesButton: document.getElementById('addNodesButton'),
            generateButton: document.getElementById('generateButton'),
            copyButton: document.getElementById('copyButton'),
            downloadButton: document.getElementById('downloadButton'),
            yamlInput: document.getElementById('yamlInput'),
            yamlOutput: document.getElementById('yamlOutput'),
            uriInput: document.getElementById('uriInput'),
            middlemanProxySelect: document.getElementById('middlemanProxy'),
            exitProxySelect: document.getElementById('exitProxy'),
            interactionZone: document.getElementById('interaction-zone'),
            statusEl: document.getElementById('status'),
            generateListenersCheckbox: document.getElementById('generateListenersCheckbox'),
            multiExitOptions: document.getElementById('multiExitOptions'),
            startPortInput: document.getElementById('startPortInput'),
            listenerTypeSelect: document.getElementById('listenerTypeSelect'),
            chainProxyContainer: document.getElementById('chainProxyContainer')
        };
        
        // 【MODIFIED AND ENHANCED】 URI Parser Object
        const uriParser = {
            parse(uri) {
                if (!uri || !uri.includes('://')) return null;
                const trimmedUri = uri.trim();
                if (trimmedUri.startsWith('ss://')) return this.parseSS(trimmedUri);
                if (trimmedUri.startsWith('vmess://')) return this.parseVmess(trimmedUri);
                if (trimmedUri.startsWith('trojan://')) return this.parseTrojan(trimmedUri);
                if (trimmedUri.startsWith('vless://')) return this.parseVless(trimmedUri);
                if (trimmedUri.startsWith('tuic://')) return this.parseTuicV5(trimmedUri);
                if (trimmedUri.startsWith('hysteria2://')) return this.parseHysteria2(trimmedUri);
                console.warn("Unsupported URI scheme:", trimmedUri);
                return null;
            },
            
            parseSS(uri) {
                try {
                    const url = new URL(uri);
                    const name = decodeURIComponent(url.hash.substring(1)) || url.hostname;
                    const userInfoDecoded = atob(url.username);
                    const firstColonIndex = userInfoDecoded.indexOf(':');
                    if (firstColonIndex === -1) return null;
                    const cipher = userInfoDecoded.substring(0, firstColonIndex);
                    const password = userInfoDecoded.substring(firstColonIndex + 1);
                    return { name, type: 'ss', server: url.hostname, port: parseInt(url.port, 10), cipher, password };
                } catch (e) {
                    console.error("Failed to parse SS URI:", uri, e);
                    return null;
                }
            },

            parseVmess(uri) {
                try {
                    const decoded = atob(uri.substring(8));
                    const config = JSON.parse(decoded);
                    const name = config.ps || `${config.add}:${config.port}`;
                    const proxy = {
                        name: name,
                        type: 'vmess',
                        server: config.add,
                        port: parseInt(config.port, 10),
                        uuid: config.id,
                        alterId: parseInt(config.aid, 10),
                        cipher: 'auto',
                        tls: config.tls === 'tls',
                        network: config.net || 'tcp',
                    };

                    if (proxy.network === 'ws') {
                        proxy['ws-opts'] = {
                            path: config.path || '/',
                            headers: { Host: config.host || config.add }
                        };
                    } else if (proxy.network === 'grpc') {
                        proxy['grpc-opts'] = {
                            'grpc-service-name': config.path || ''
                        };
                    }
                    if (proxy.tls) {
                         proxy['servername'] = config.host || config.add;
                    }
                    return proxy;
                } catch (e) {
                    console.error("Failed to parse Vmess URI:", uri, e);
                    return null;
                }
            },

            parseTrojan(uri) {
                try {
                    const url = new URL(uri);
                    const name = decodeURIComponent(url.hash.substring(1)) || url.hostname;
                    const params = new URLSearchParams(url.search);
                    return {
                        name,
                        type: 'trojan',
                        server: url.hostname,
                        port: parseInt(url.port, 10),
                        password: url.username,
                        sni: params.get('sni') || url.hostname,
                        'skip-cert-verify': params.get('allowInsecure') === '1' || params.get('allowInsecure') === 'true'
                    };
                } catch (e) {
                    console.error("Failed to parse Trojan URI:", uri, e);
                    return null;
                }
            },
            
            parseVless(uri) {
                try {
                    const url = new URL(uri);
                    const params = new URLSearchParams(url.search);
                    const name = decodeURIComponent(url.hash.substring(1)) || url.hostname;

                    const proxy = {
                        name: name,
                        type: 'vless',
                        server: url.hostname,
                        port: parseInt(url.port, 10),
                        uuid: url.username,
                        network: params.get('type') || 'tcp',
                        tls: params.get('security') === 'tls' || params.get('security') === 'reality',
                        flow: params.get('flow') || '',
                    };

                    if (proxy.tls) {
                        proxy['servername'] = params.get('sni') || url.hostname;
                        proxy['client-fingerprint'] = params.get('fp') || 'chrome';
                        
                        if (params.get('security') === 'reality') {
                            proxy['reality-opts'] = {
                                'public-key': params.get('pbk'),
                                'short-id': params.get('sid') || '',
                            };
                        }
                    }

                    if (proxy.network === 'ws') {
                        proxy['ws-opts'] = {
                            path: params.get('path') || '/',
                            headers: { Host: params.get('host') || url.hostname }
                        };
                    } else if (proxy.network === 'grpc') {
                        proxy['grpc-opts'] = {
                            'grpc-service-name': params.get('serviceName') || ''
                        };
                    }
                    
                    return proxy;
                } catch (e) {
                    console.error("Failed to parse VLESS URI:", uri, e);
                    return null;
                }
            },
            
            parseTuicV5(uri) {
                try {
                    const url = new URL(uri);
                    const params = new URLSearchParams(url.search);
                    const name = decodeURIComponent(url.hash.substring(1)) || url.hostname;
                    const [uuid, password] = url.username.split(':');

                    return {
                        name: name,
                        type: 'tuic',
                        server: url.hostname,
                        port: parseInt(url.port, 10),
                        uuid: uuid,
                        password: password,
                        sni: params.get('sni') || url.hostname,
                        'skip-cert-verify': params.get('allow_insecure') === '1',
                        'udp-relay-mode': params.get('udp_relay_mode') || 'native',
                        alpn: (params.get('alpn') || '').split(',').filter(Boolean),
                        'congestion-controller': params.get('congestion_control') || 'bbr',
                    };
                } catch (e) {
                    console.error("Failed to parse TUIC URI:", uri, e);
                    return null;
                }
            },

            parseHysteria2(uri) {
                try {
                    const url = new URL(uri);
                    const params = new URLSearchParams(url.search);
                    const name = decodeURIComponent(url.hash.substring(1)) || url.hostname;

                    return {
                        name: name,
                        type: 'hysteria2',
                        server: url.hostname,
                        port: parseInt(url.port, 10),
                        password: url.username,
                        sni: params.get('sni') || url.hostname,
                        'skip-cert-verify': params.get('insecure') === '1',
                    };
                } catch (e) {
                    console.error("Failed to parse Hysteria2 URI:", uri, e);
                    return null;
                }
            }
        };

        ui.parseButton.addEventListener('click', () => {
            let yamlText = ui.yamlInput.value.trim();
            if (!yamlText) {
                yamlText = BASE_TEMPLATE;
                showStatus('输入为空，已载入基础配置模板。', 'info');
            }
            try {
                parsedConfig = jsyaml.load(yamlText);
                if (!parsedConfig || typeof parsedConfig !== 'object') throw new Error('无效的配置格式。');
                if (!parsedConfig.proxies) parsedConfig.proxies = [];
                if (!parsedConfig['proxy-groups']) parsedConfig['proxy-groups'] = [];
                updateAllSelectors();
                ui.interactionZone.style.display = 'block';
                if (yamlText !== BASE_TEMPLATE) showStatus('基础配置解析成功！', 'success');
            } catch (e) {
                parsedConfig = null;
                ui.interactionZone.style.display = 'none';
                showStatus(`解析失败: ${e.message}`, 'error');
            }
        });

        ui.addNodesButton.addEventListener('click', () => {
            if (!parsedConfig) return showStatus('请先解析您的基础配置！', 'error');
            const uriText = ui.uriInput.value.trim();
            if (!uriText) return showStatus('请在上方文本框中粘贴节点链接！', 'error');
            const uriList = uriText.split(/\r?\n/).filter(line => line.trim());
            const newProxies = uriList.map(uri => uriParser.parse(uri)).filter(Boolean);
            if (newProxies.length === 0) return showStatus('未解析到有效节点，请检查链接格式！', 'error');
            const existingNames = new Set(parsedConfig.proxies.map(p => p.name));
            let addedCount = 0;
            const addedProxyNames = [];
            newProxies.forEach(newNode => {
                let finalName = newNode.name;
                let count = 1;
                while (existingNames.has(finalName)) { finalName = `${newNode.name}_${count++}`; }
                newNode.name = finalName;
                parsedConfig.proxies.push(newNode);
                existingNames.add(newNode.name);
                addedProxyNames.push(newNode.name);
                addedCount++;
            });
            if (parsedConfig['proxy-groups']) {
                parsedConfig['proxy-groups'].forEach(group => {
                    if (Array.isArray(group.proxies)) {
                        addedProxyNames.forEach(name => {
                            if (!group.proxies.includes(name)) { group.proxies.push(name); }
                        });
                    }
                });
            }
            updateAllSelectors();
            showStatus(`操作成功！添加了 ${addedCount} 个新节点。`, 'success');
        });

        ui.generateListenersCheckbox.addEventListener('change', () => {
            const isChecked = ui.generateListenersCheckbox.checked;
            ui.multiExitOptions.style.display = isChecked ? 'grid' : 'none';
            ui.middlemanProxySelect.disabled = isChecked;
            ui.exitProxySelect.disabled = isChecked;
            ui.chainProxyContainer.style.opacity = isChecked ? 0.5 : 1;
        });

        ui.generateButton.addEventListener('click', () => {
            if (!parsedConfig || !parsedConfig.proxies) return showStatus('没有可用的代理节点来生成配置！', 'error');
            
            const newConfig = JSON.parse(JSON.stringify(parsedConfig));
            
            if (ui.generateListenersCheckbox.checked) {
                // --- Mode B: Multi-Exit Listeners ---
                if (newConfig.proxies.length === 0) return showStatus('没有代理节点，无法生成监听器。', 'error');

                const startPort = parseInt(ui.startPortInput.value, 10);
                if (isNaN(startPort)) return showStatus('起始端口号无效！', 'error');
                const listenerType = ui.listenerTypeSelect.value;
                
                const listeners = newConfig.proxies.map((proxy, index) => ({
                    name: `${listenerType}-${startPort + index}`, // Give listeners unique names
                    type: listenerType,
                    address: '0.0.0.0', // Listen on all interfaces
                    port: startPort + index,
                    proxy: proxy.name
                }));
                
                newConfig['listeners'] = listeners;
                newConfig['dns'] = DNS_TEMPLATE;
                newConfig['allow-lan'] = true;
                // Clean up legacy port settings to avoid conflicts
                delete newConfig['port'];
                delete newConfig['socks-port'];
                delete newConfig['mixed-port'];
                delete newConfig['redir-port'];

                showStatus(`成功生成 ${listeners.length} 个多出口本地监听！`, 'success');

            } else {
                // --- Mode A: Dialer-Proxy (Original Logic) ---
                newConfig.proxies.forEach(proxy => delete proxy['dialer-proxy']);
                const middleman = ui.middlemanProxySelect.value;
                const exit = ui.exitProxySelect.value;
                if (middleman && exit) {
                    if (middleman === exit) return showStatus('跳板和出口不能是同一个代理！', 'error');
                    const exitProxyObject = newConfig.proxies.find(p => p.name === exit);
                    if (exitProxyObject) {
                        exitProxyObject['dialer-proxy'] = middleman;
                        showStatus('链式代理配置已成功生成！', 'success');
                    } else {
                        return showStatus(`错误：在配置中找不到名为 "${exit}" 的代理。`, 'error');
                    }
                } else {
                    showStatus('未选择链式代理，已生成常规配置。', 'info');
                }
            }

            const newYamlText = jsyaml.dump(newConfig, { lineWidth: -1, quotingType: '"' });
            ui.yamlOutput.value = newYamlText;
            ui.copyButton.style.display = 'block';
            ui.downloadButton.style.display = 'block';
        });

        ui.copyButton.addEventListener('click', () => { navigator.clipboard.writeText(ui.yamlOutput.value).then(()=>{const t=ui.copyButton.textContent;ui.copyButton.textContent="已复制!",showStatus("已复制到剪贴板！","success"),setTimeout(()=>{ui.copyButton.textContent=t},2e3)}).catch(t=>showStatus(`复制失败: ${t}`,"error"))});
        
        ui.downloadButton.addEventListener('click', () => {
            const yamlText = ui.yamlOutput.value;
            if (!yamlText) { showStatus('没有可下载的配置内容。', 'error'); return; }
            const blob = new Blob([yamlText], { type: 'application/x-yaml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'config.yaml';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showStatus('下载已开始...', 'success');
        });

        function updateAllSelectors() {
            const proxyNames = parsedConfig.proxies.map(p => p.name);
            populateSelect(ui.middlemanProxySelect, proxyNames, '-- 不选择 --');
            populateSelect(ui.exitProxySelect, proxyNames, '-- 不选择 --');
        }

        function populateSelect(selectElement, options, defaultOptionText) {
            const currentValue = selectElement.value;
            selectElement.innerHTML = `<option value="">${defaultOptionText}</option>`;
            if (options.length === 0 && selectElement.id.includes('Proxy')) {
                selectElement.innerHTML = '<option value="">-- 无可用代理 --</option>';
                return;
            }
            options.forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option;
                optionElement.textContent = option;
                selectElement.appendChild(optionElement);
            });
            if (options.includes(currentValue)) selectElement.value = currentValue;
        }

        function showStatus(message, type = 'info') {
            ui.statusEl.textContent = message;
            ui.statusEl.className = `status-${type}`;
        }
    </script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"rayId":"972e9e4f0ef984bd","version":"2025.8.0","r":1,"token":"26c46eca1b214242a2840f13b0c85015","serverTiming":{"name":{"cfExtPri":true,"cfEdge":true,"cfOrigin":true,"cfL4":true,"cfSpeedBrain":true,"cfCacheStatus":true}}}' crossorigin="anonymous"></script>
</body>

</html>
